{"data":{"type":"pages","id":"concept/labels","attributes":{"html":"<h1 id=\"usinglabelsasdirectreferencestoelementswithtestselectors\">Using labels as direct references to elements with test selectors</h1>\n<p>As explained <LinkTo @route=\"page\" @model=\"concept/truth\">previously</LinkTo>, we want to move the truth from step implementations to feature files. A great way to do it is with test selectors.</p>\n<p>To learn about test selectors, please see the <a href=\"https://github.com/simplabs/ember-test-selectors\">ember-test-selectors</a> addon. Though you can start using test selectors without the addon, it is recommended to have it installed in your app.</p>\n<p><code>ember-cli-yadda-opinonated</code> introduces <em>labels</em>: a DSL for your Cucumber feature files that lets you reference page elements via test selectors.</p>\n<p>In its simplest form, a label can look like: <code>Menu-Item</code>, <code>MenuItem</code> or <code>menu-item</code>. Any of these lables translates to <code>[data-test-menu-item]</code>.</p>\n<p>You can also use articles. They will be ignored by the addon, but will contribute to readability: <code>a Menu-Item</code> and <code>the Menu-Item</code> behave identically to <code>Menu-Item</code>.</p>\n<p>Resulting steps could looks like this:</p>\n<pre><code class=\"feature language-feature\">When I click the Info-Button\nThen there should be an Info-Box\n</code></pre>\n<p>These steps are equivalent to:</p>\n<pre><code class=\"js language-js\">await click('[data-test-info-button']);\nassert.ok(find('[data-test-info-box']));\n</code></pre>\n<h2 id=\"targetingnestedelements\">Targeting nested elements</h2>\n<p>You can nest labels using prepositions <code>in</code>, <code>inside</code>, <code>under</code>, <code>of</code>, <code>on</code> and <code>from</code>.</p>\n<p>For example, <code>Save-Button in Post-Edit-Form</code> produces selector <code>[data-test-post-edit-form] [data-test-save-button]</code>.</p>\n<p>You can nest selectors up to 5 levels deep.</p>\n<p>Note how the order of elements is inverted. This is because for a human it's more convenient to say \"A menu item in the main menu\" than \"A main menu-contained menu item\". But CSS requires the ancestor to appear before the descendant.</p>\n<h2 id=\"referencingnthelement\">Referencing Nth element</h2>\n<p>If you have multiple elements on the same page and you want to target one of them by index, you can use index prefixes like: <code>1st</code>, <code>2nd</code>, <code>3rd</code>, <code>4th</code>, <code>543rd</code>, etc. Since we're using a natural language, they are one-indexed.</p>\n<p>Literal indices from <code>first</code> to <code>tenth</code> are also available.</p>\n<p>Label <code>2nd Menu-Item</code>, <code>the 2nd Menu-Item</code>, <code>second Menu-Item</code> or <code>the second Menu-Item</code> produce selector <code>[data-test-menu-item]:eq(1)</code> internally.</p>\n<p><code>:eq(n)</code> is not a standard selector, it is an equivalent to <code>array[n]</code> in JS. The idea is borrowed <a href=\"https://api.jquery.com/eq-selector/\">from jQuery</a>.</p>\n<p>Thus, <code>[data-test-menu-item]:eq(1)</code> will find all menu items on the page, then pick the second one.</p>\n<p>Note that this is totally different from <code>:nth-child(n)</code>, which can target more than one element!</p>\n<p>Here's a more complicated example:</p>\n<pre><code>Link in 2nd Menu-Item from the 1st Menu\n</code></pre>\n<p>This will find the first menu, in that menu it will take the second menu item, and in that menu item it will take a link:</p>\n<pre><code>[data-test-menu]:eq(0) [data-test-menu-item]:eq(1) [data-test-link]\n</code></pre>\n<h2 id=\"compoundlabels\">Compound labels</h2>\n<p>Each element you want to target should have one semantic label.</p>\n<p>In addition to a semantic label, you might want to add additional labels on the same element. Here are two common cases:</p>\n<ul>\n<li>Distinguishing sibling items. E. g. each menu item may have a unique label such as <code>Home</code>, <code>Products</code>, <code>About</code>, <code>Contacts</code>, etc.</li>\n<li>Tracking state: <code>Active</code>, <code>Expanded</code>, etc.</li>\n</ul>\n<p>Use <code>+</code> to compose multiple labels.</p>\n<p>E. g. you can target an active menu item with <code>Active+MenuItem</code>. This will translate to <code>[data-test-menu-item][data-test-active]</code>.</p>\n<p>Note that you can use the <strong>label map</strong> (see below) to map the <code>Active</code> label to the <code>.active</code> selector. If you do, <code>Active+MenuItem</code> will translate to <code>[data-test-menu-item].active</code>.</p>\n<h2 id=\"testattributevalues\">Test attribute values</h2>\n<p>You can distinguish sibling items with values of test selectors: <code>Menu-Item(Products)</code> targes <code>[data-test-menu-item=\"Products\"]</code>.</p>\n<p>Note that unlike attribute names, values are case-sensitive.</p>\n<h2 id=\"usinglabelsforthirdpartycomponents\">Using labels for third-party components</h2>\n<p>Labels are designed to prevent you from using non-semantic selectors, which are pure evil. But there's a situation where this evil is inevitable.</p>\n<p>Sometimes you want your tests to operate on page elements produced by a third-party addon or library. You don't have control over its HTML output and thus can't sprinkle it with test selectors.</p>\n<p>To resolve the issue, you can provide a mapping of labels to selectors. For example, you can configure a label <code>Bootstrap-Text-Input</code> to target <code>input.form-control[type=\"text\"]</code>.</p>\n<p>You should only use it to target HTML that you are unable to edit. If you can, you should instead add test selectors to elements and use normal, unmapped labels to target them.</p>","title":"Labels for test selectors","index":3}}}