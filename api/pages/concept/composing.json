{"data":{"type":"pages","id":"concept/composing","attributes":{"html":"<h1 id=\"composingyaddastepimplementations\">Composing Yadda step implementations</h1>\n<h2 id=\"theproblem\">The problem</h2>\n<p><a href=\"https://github.com/acuminous/yadda\">Yadda</a>, the Cucumber implementation behind this addon, uses method chains to register step implementations. Here's an example from the <a href=\"https://github.com/albertjan/ember-cli-yadda\">ember-cli-yadda</a> readme:</p>\n<pre><code class=\"js language-js\">import steps from 'my-app/tests/acceptance/steps/steps';\n\nexport default function(assert) {\n  return steps(assert)\n    .given('it\\'s next to apples', function() {\n      let apples = this.element.querySelectorAll('.apple');\n      assert.ok(apples.length &gt; 0)\n    })\n    .when('left together for a while', function(next) {\n      // bananas rot really quickly next to apples.\n      setTimeout(next, 1000);\n    })\n    .then('the banana rots', function () {\n      let banana = this.element.querySelector('.banana');\n      assert.ok(banana.classList.contains('rotten'));\n    });\n}\n</code></pre>\n<p>This approach has disadvantages:</p>\n<ul>\n<li><p>It's quite boilerplatey.</p></li>\n<li><p>It has a lot of visual noise, the code is harder to read than it could be.</p></li>\n<li><p>It does not allow step composition. You can only inherit one file from another (similar to JS class inheritance), whereas assembling a library from multiple sources would be handy (similar to mixins).</p></li>\n<li><p>Steps can only be organized into files <em>by feature</em>, whereas most steps can be used in multiple features.</p>\n<p>For example, you have some generic <code>steps.js</code> and then you have acceptance-test specific <code>login-steps.js</code>. According to <code>ember-cli-yadda</code> stadnard, <code>login-steps.js</code> inherits from <code>steps.js</code>.</p>\n<p>Now imagine you're building another accepntance test with <code>post-steps.js</code> that also inherits from <code>steps.js</code>. You have a use case where an anonymous user must see a post without edit button, then login and see the edit button. You have the login step already implemented in <code>login-steps.js</code>, so you inherit <code>post-steps.js</code> from  <code>login-steps.js</code>.</p>\n<p>Now Yadda will complain about conflicting steps and refuse to start: <code>steps.js</code> was inherited twice.</p>\n<p>You can work around this by not inheriting <code>post-steps.js</code> from <code>steps.js</code>. This works, but only until you want to borrow some more steps from another step file: if two step files inherit from <code>steps.js</code>, you can't inherit from both! :(</p>\n<p>The only solution is to move all shared steps to the generic <code>steps.js</code>. Eventually it becomes large, mixed up, hard to read and to maintain.</p></li>\n</ul>\n<h2 id=\"thesolution\">The solution</h2>\n<p><code>ember-cli-yadda-opinionated</code> lets you store steps in simple objects with methods. The above example can be rewritten like this:</p>\n<pre><code class=\"js language-js\">// tests/acceptance/steps/_fruit-steps.js\n\nexport default {\n\n  \"Given it's next to apples\" (assert) {\n    let apples = this.element.querySelectorAll('.apple');\n    assert.ok(apples.length &gt; 0)\n  },\n\n  'When left together for a while', function() {\n    // next() is not available. Return a promise or use async/await.\n    return new Promise(resolve =&gt; setTimeout(resolve, 1000)); \n  }),\n\n  'Then the banana rots', function () {\n    let banana = this.element.querySelector('.banana');\n    assert.ok(banana.classList.contains('rotten'));\n  },\n\n};\n</code></pre>\n<p>This is cleaner and easier to read.</p>\n<p>(Note: this example is borrowed from the Yadda readme and is not using the opinionated approach of <LinkTo @route=\"page\" @model=\"concept/truth\">reusable steps</LinkTo> and <LinkTo  @route=\"page\" @model=\"concept/labels\">labels</LinkTo>.)</p>\n<p><code>ember-cli-yadda-opinionated</code> lets you organize steps <em>by topic</em>, not directly bound to a specific feature. For example, you can have a collection of <em>authentication</em> steps and use them in all features that require anonymous/authenticated/admin user, logging out, etc.</p>\n<p>You can compose such steps with the <code>composeSteps</code> helper. It lets you include steps from multiple sources.</p>\n<p>Conflicting step names will not crash your test suite, letting you manually control the composition: the last conflicting step overwrites previous ones.</p>\n<p>The plain object approach lets you run one step from another:</p>\n<pre><code class=\"js language-js\">export default const steps = {\n\n  // A one-liner step to seed a single post\n  \"Given a post with $fields\"(fields) {\n    /* seeding */\n  },\n\n  // A step that uses table syntax: useful to seed multiple records,\n  // but not practical to seed just one, since it consumes at least four lines of the feature file\n  \"Given the following posts with\\n$opinionatedTable\"(rows) {\n    rows.forEach(row =&gt; {\n      steps[\"Given a post with $fields\"].call(this, row);\n    })\n  },\n\n};\n</code></pre>","title":"Composing step implementations","index":4}}}