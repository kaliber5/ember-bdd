{"data":{"type":"pages","id":"usage/dictionary","attributes":{"html":"<h1 id=\"thedictionary\">The dictionary</h1>\n<h2 id=\"usingregularexpressionsinstepnames\">Using regular expressions in step names</h2>\n<p>Yadda allows usage of regualr expressions in step names, emabling step implementations to be highly reusable.</p>\n<p>Here's an example of a step implementation with a regular expression:</p>\n<pre><code class=\"feature language-feature\">Then the page title should be \"Hello World\"\n</code></pre>\n<pre><code class=\"js language-js\">{\n  'Then the page title should be (.+)'(expectedStr) {\n    expectedStr; // =&gt; 'Hello World'\n    expect(window.document.title).equal(expectedStr);\n  }\n}\n</code></pre>\n<p>Each capturing group is represented by an argument of the step implementation function, in the order of appearance.</p>\n<h2 id=\"usingundefinedmarcos\">Using undefined marcos</h2>\n<p>You can use macros in the form of <code>$macroName</code> in place of regular expressions.</p>\n<p>If you have not defined the macro you're using, then it will <a href=\"https://github.com/acuminous/yadda/blob/v2.1.0/lib/Dictionary.js#L69\">default to</a> the <code>(.+)</code> regular expressuon.</p>\n<pre><code class=\"feature language-feature\">Then the page title should be \"Hello World\"\n</code></pre>\n<pre><code class=\"js language-js\">{\n  'Then the page title should be $str'(expectedStr) {\n    expectedStr; // =&gt; 'Hello World'\n    expect(window.document.title).equal(expectedStr);\n  }\n}\n</code></pre>\n<p>âš  We do not recommend using undefined macros due to their ambiguity. Either use regular expressions explicitly or use defined macros with narrow purpose.</p>\n<h2 id=\"definingmacros\">Defining macros</h2>\n<p>Macros go into the <em>dictionary</em> located at:</p>\n<pre><code>tests/bdd/dictionary.js\n</code></pre>\n<p>This file should have a default export of an object: a record with macro definitions.</p>\n<p>There are a number of ways to define a macro:</p>\n<pre><code class=\"js language-js\">  export default {\n    // A regular expression with a capturing group\n    $email: /(.+?@.+)/, // john.doe@example.com\n\n    // A regular expression with multiple capturing groups\n    $fullName: /(.+?) (.+?)/, // John Doe\n\n    // An alias delegating to another macro\n    $eMail: '$email',\n\n    // An alias delegating to multiple aliases\n    $fullNameWithEmail: '$fullName &lt;$email&gt;', // John Doe &lt;john.doe@example.com&gt;\n\n    // A tuple of a regular expression and a converter function\n    $index: [\n      /(\\d+)/,\n      (numberStr) =&gt; parseInt(numberStr, 10) - 1;\n    ],\n  };\n</code></pre>\n<h2 id=\"implementingconverters\">Implementing converters</h2>\n<p>All values extracted by regular expressions come as strings. A converter lets you convert a string into something else:</p>\n<ul>\n<li>a modified string;</li>\n<li>a number;</li>\n<li>a <code>Date</code> object;</li>\n<li>a DOM element from the DOM;</li>\n<li>a database record (in case you're using a frontend data layer such as <a href=\"https://miragejs.com\">Mirage</a>);</li>\n<li>etc.</li>\n</ul>\n<p>A converter is a function that accepts strings from capturing groups and returns a value for your step implemenation to consume:</p>\n<pre><code class=\"feature language-feature\">Then the 2nd .title should be \"Hello world\"\n</code></pre>\n<pre><code class=\"js language-js\">export default {\n  $index: [\n    /(\\d+)(?:st|nd|rd|th)/, // ?: means a non-capturing group\n    (numberStr) =&gt; parseInt(numberStr, 10) - 1,\n  ],\n\n  $collection: [\n    /(.+)/,\n    (selector) =&gt; Array.from(document.querySelectorAll(selector)),\n  ],\n}\n</code></pre>\n<pre><code class=\"js language-js\">import { expect } from 'chai';\n\nexport default {\n  'Then the $element should be $quotedString'(element, text) {\n    expect(element, 'Element not found').ok;\n    expect(element.textContent.trim()).equal(text);\n  }\n}\n</code></pre>","title":"Dictionary","index":2}}}