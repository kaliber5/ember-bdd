{"data":{"type":"pages","id":"usage/project-structure","attributes":{"html":"<h1 id=\"projectstructure\">Project structure</h1>\n<h2 id=\"teststesthelperjs\">/tests/test-helper.js</h2>\n<p>This file is an entry point for your Ember tests. Add this to initialize <code>ember-bdd</code>:</p>\n<pre><code class=\"js language-js\">import { init as initEmberBDD } from '@ember-bdd/core/test-support/index';\n\ninitEmberBDD();\n</code></pre>\n<h2 id=\"testsbddstepsjs\">/tests/bdd/steps.js</h2>\n<p>This file must export an object containing step implementations.</p>\n<p>When using <code>yadda</code> directly, it requires defining a collection of step implementations individually for each feature files. Since <code>ember-bdd</code> advocates for using a compact library of fully reusable, feature-unspecific steps, it instead defines a single collection of step implemenations that is shared across all feature files.</p>\n<pre><code class=\"js language-js\">// Default steps: DOM, localStorage, debug, system\nimport { steps as main } from '@ember-bdd/main/test-support';\n\n// Addon-specific steps (comment out if you don't use the addon)\nimport { steps as mirage } from '@ember-bdd/mirage/test-support';\nimport { steps as powerDatePicker } from '@ember-bdd/power-date-picker/test-support';\nimport { steps as powerSelect } from '@ember-bdd/power-select/test-support';\nimport { steps as windowMock } from '@ember-bdd/window-mock/test-support';\n\n// Your handwritten steps\nimport myConfigurationEngine from './stpes/configuration-engine';\nimport mySortableTable from './stpes/sortable-table';\n\nexport default {\n  ...dom,\n  ...localStorage,\n  ...system,\n\n  ...mirage,\n  ...powerDatePicker,\n  ...powerSelect,\n  ...windowMock,\n\n  ...myconfigurationEngine,\n  ...mySortableTable,\n}\n</code></pre>\n<h2 id=\"testsbddstepsjs-1\">/tests/bdd/steps/*.js</h2>\n<p>This is where you define custom step implementations:</p>\n<pre><code class=\"js language-js\">import { setConfigurationState } from 'my-app/utils/configuration';\n\nexport default {\n  'Given the app has the following memorized state:\\n$opinionatedJSONObject'(requestedState) {\n    return setConfigurationState(requestedState);\n  },\n}\n</code></pre>\n<p>See <LinkTo @route=\"page\" @model=\"index\">Defining custom step implementations</LinkTo> for details.</p>\n<h2 id=\"testsbdddictionaryjs\">/tests/bdd/dictionary.js</h2>\n<p>This is where you populate the Yadda dictionary with converters (aka macros) which can be used in the names of step implementations:</p>\n<pre><code class=\"js language-js\">import {\n  date,\n  integer,\n  float,\n  list,\n  table,\n  json,\n  string,\n } from '@mber-bdd/core/test-support/converters';\n\n import { modelName } from '@ember-bdd/mirage';\n\nexport default {\n    date,\n    integer,\n    float,\n    list,\n    table,\n    json,\n    string,\n    modelName,\n}\n</code></pre>\n<p>See <LinkTo @route=\"page\" @model=\"index\">Populating the dictionary</LinkTo> for details.</p>\n<h2 id=\"testsbddcustomlabelsjs\">/tests/bdd/custom-labels.js</h2>\n<p>Normally you should reference DOM elements via semantic test selectors. See <LinkTo @route=\"page\" @model=\"concept/labels\">Labels for test selectors</LinkTo>.</p>\n<p>But sometimes you have to deal with third-party components. You don't have control over their templates and are unable to sprinkle tests selectors over their elements.</p>\n<p>Custom labels to the rescue! Define some labels to serve as aliases for arbitrary selectors:</p>\n<pre><code class=\"js language-js\">{\n  'Bootstrap-Field-Error': '.invalid-feedback',\n}\n</code></pre>\n<p>Please read up on <LinkTo @route=\"page\" @model=\"index\">Custom labels</LinkTo>.</p>\n<h2 id=\"testsbddannotationsjs\">/tests/bdd/annotations.js</h2>\n<p>This is where you define annotations that let you initialize tests in different ways.</p>\n<p>You need to prefix every feature with <code>@setupApplicationTest</code> in order for Ember and QUnit to set up tests propertly.</p>\n<p>You can prefix a feature or a scenario with <code>@skip</code> in order not to run it.</p>\n<p>Normally, you would put all intialization into the <code>setupApplicationTest</code> annotation. But in case you have conflicting test initializations, you can put them into individual annotations and use them explicitly together with <code>@setupApplicationTest</code>.</p>\n<pre><code class=\"js language-js\">import { setupApplicationTest } from 'ember-qunit';\n\nimport { setupMirage } from 'ember-cli-mirage/test-support';\nimport setupWindowMock from './setup-window-mock';\n\nimport { setup as setupEmberBddMain } from '@ember-bdd/main';\n\nimport setupResetState from './setup-reset-app';\n\nexport default {\n  skip(test) {\n    console.info(`Skipping ${test.type} \"${test.title}\"`);\n    return fazse; // Prevents test execution\n  },\n\n  setupApplicationTest(_text, hooks) {\n    // Ember QUnit default initialization\n    setupApplicationTest(hooks);\n\n    // Third party addons initialization\n    setupMirage(hooks);\n    setupWindowMock(hooks);\n\n    // ember-bdd initialization\n    setupEmberBddMain(hooks);\n\n    // Your own initializaion\n    setupResetState(hooks);\n  },\n}\n</code></pre>\n<p>See <LinkTo @route=\"page\" @model=\"index\">Defining annotations</LinkTo> for details.</p>\n<h2 id=\"testsacceptancefeature\">/tests/acceptance/*.feature</h2>\n<p>These are your feature files. A feature file is equvalent to an acceptance test file.</p>\n<p>Normally, the content of each feature file should be prefixed with <code>@setupApplicationTest</code>.</p>\n<p>See <LinkTo @route=\"page\" @model=\"index\">How to write features</LinkTo> for details.</p>\n<h2 id=\"testsacceptancestepsstepsjs\">/tests/acceptance/steps/*-steps.js</h2>\n<p><strong>Normally, you don't need these files</strong>, so they don't exist by default.</p>\n<p>If you create one, it must be paired with a feature file, e. g.:</p>\n<p><code>`\n/tests/acceptance/shop-page.feature\n/tests/acceptance/steps/shop-page-steps.js\n</code></p>\n<p><code>*-steps.js</code> files let you override the <code>ember-bdd</code> pipeline (described above) for individual features, letting you set up Yadda manually.</p>\n<p>This might be useful in one of two cases:</p>\n<ul>\n<li>Support legacy <a href=\"https://github.com/kaliber5/ember-cli-yadda\">ember-cli-yadda</a> tests or vanilla <a href=\"https://github.com/acuminous/yadda\">Yadda</a> tests.</li>\n<li>Avoid conflicts in step names or converters (macros).</li>\n</ul>\n<p>We do not recommend using this aproach. Instead, you should refactor your legacy tests for <code>ember-bdd</code> or rename your steps and macros to eliminate conflicts.</p>\n<p>See <LinkTo @route=\"page\" @model=\"index\">Setting up Yadda manually</LinkTo> for details.</p>","title":"Project Structure","index":1}}}